=======================================================
Comparison with elasticsearch-py, the "Official Client"
=======================================================

pyelasticsearch was created before Elasticsearch-the-company provided its own
client libraries for anything other than Java. There was no reliable,
large-scale ES client for Python: pyes was closest, but it suffered from
unreliability and pervasive weirdness, like closing sockets in ``__del__`` and
doing things which were obvious no-ops. We adapted pyelasticsearch from an
older, very simple client library and gave it a complete API overhaul in
version 0.2, inspired by the principles of `poetic API design
<https://www.youtube.com/watch?v=JQYnFyG7A8c>`_.

Elasticsearch-the-company later created its own clients, with a strong leaning
toward keeping them similar across languages for ease of support and
maintenance. The upside is that their libraries always support the latest ES
features, down to every last nook and cranny, because the relevant parts are
autogenerated from a generic API description language. The downside is that
they feel autogenerated: some things end up less than Pythonic.


Which Should You Use?
=====================

The official Python client borrows much design—and code—from pyelasticsearch.
Starting in 1.0, we return the favor, using elasticsearch-py's transport layer
rather than maintaining our own. The important differences remain at the API
level.

In general, pyelasticsearch focuses on...

* Pythonic-ness

  pyelasticsearch is designed to feel elegant to the caller. For example, we
  strive for symmetry: creating an index is ``es.create()``, and searching one
  is ``es.search()``. In elasticsearch-py, creating an index is
  nested inside ``es.indices.create(<index name>)``, an artifact of code
  organization. The tradeoff for added design thought is that the project moves slower.

* Safety

  If something fails, it always raises an exception, making it hard to
  accidentally ignore. elasticsearch-py doesn't always do this: you need to
  check for errors explicitly when using its bulk indexing helper, for example.

  In addition, data loss is hard to stumble into; we put up guiderails. For
  example, calling the update-settings API with no indices would, if we simply
  followed the ES REST API, update all indices, a far-reaching destructive
  action caused by an omission. We require the explicit use of an
  ``update_all_settings()`` method if you want to do this.

* Better documentation

  Our top-level docs are comprehensive with regard to our API, we link to the
  ES docs for details about their system, and we try to respect the Law of
  Demeter in our layering.

Conversely, elasticsearch-py focuses on...

* Exhaustive functionality

  It provides explicit hooks into every corner of ES and keeps up to date with
  ES releases.

  Our strategy is to provide :ref:`forward-compatibility-kwargs` (which
  elasticsearch-py adopted as well) and
  :meth:`~pyelasticsearch.ElasticSearch.send_request()` for the period between
  an ES release and when we design APIs for its new features.

* Cross-language homogeneity

  If you're using ES from multiple languages every day, you might enjoy an API
  that looks similar across them.

  Conversely, we aim for idiomatic Python.
